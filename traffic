#!/usr/bin/env python

import sys, os

if len( sys.argv ) > 1 and sys.argv[1] == 'autoconf':
	#TODO: check for chains?
	print( 'yes' )

def get_bool( val ):
	if val.lower() in [ 'n', 'no', 'false' ]:
		return False
	else:
		return True

class chain():
	def __init__( self, line ):
		info = line.split()
		self.name = info[1]
		self.rules = []

	def add_header( self, header ):
		self.names = header.split()

	def add_rule( self, raw_rule ):
		fields = raw_rule.split( None, len( self.names )-1)
		self.rules.append( dict( zip( self.names, fields ) ) )

	def get_bytes( self, destination, ip_version, protocol ):
		if ip_version == 'ipv4':
			destination = '%s %s'%(protocol, destination)

		for rule in self.rules:
			if rule['destination'] == destination:
				return int(rule['bytes'])
		return None

# see what we want to count:
use_v6 = get_bool( os.environ.pop( 'ipv6', 'y' ) )
use_v4 = get_bool( os.environ.pop( 'ipv4', 'y' ) )
use_tcp = get_bool( os.environ.pop( 'tcp', 'y' ) )
use_udp = get_bool( os.environ.pop( 'udp', 'y' ) )
ports = os.environ.pop( 'ports', '' ).split()

from subprocess import Popen, PIPE

def parse_tables( binary ):
	p = Popen( [ binary, '-L', '-n', '-v', '-x' ], stdout=PIPE )
	stdout = p.communicate()[0].splitlines()

	chains = {}
	cur_chain = None
	for line in stdout:
		l = line.lower().strip()
		if not l: # empty line
			continue
		elif l.startswith('chain'): # new chain definition
			cur_chain = chain( l )
			chains[cur_chain.name] = cur_chain
			continue
		elif l.startswith('pkts'): # header line
			cur_chain.add_header( l )
		else:
			cur_chain.add_rule( l )
	return chains

v6_total = 0
v4_total = 0

def print_traffic( ports, protocol, ip_version, chains ):
	printed_traffic = 0
	in_chain = chains.pop( 'count_%s_in'%protocol, None )
	out_chain = chains.pop( 'count_%s_out'%protocol, None )
	
	for port in ports:
		prefix = '%s_%s_%s_'%(protocol, port, ip_version)
		if in_chain:
			in_bytes = in_chain.get_bytes( 'dpt:%s'%port, ip_version, protocol )
			if in_bytes != None:
				print( '%sin.value %s'%(prefix, in_bytes) )
				printed_traffic += in_bytes
		if out_chain:
			out_bytes = out_chain.get_bytes( 'spt:%s'%port, ip_version, protocol )
			if out_bytes != None:
				print( '%sout.value %s'%(prefix, out_bytes) )
				printed_traffic += out_bytes

	return printed_traffic

def print_traffic_config( ports, protocol, ip_version, chains ):
	in_chain = chains.pop( 'count_%s_in'%protocol, None )
	out_chain = chains.pop( 'count_%s_out'%protocol, None )
	
	for port in ports:
		prefix = '%s_%s_%s_'%(protocol, port, ip_version)
		if in_chain:
			in_bytes = in_chain.get_bytes( 'dpt:%s'%port, ip_version, protocol )
			if in_bytes != None:
				field = '%sin'%prefix
				label = 'Port %s/tcp (incoming)'%port
				print( '%s.label %s'%(field, label) )
				print( '%s.type DERIVE'%field )
				print( '%s.min 0'%field )
		if out_chain:
			out_bytes = out_chain.get_bytes( 'spt:%s'%port, ip_version, protocol )
			if out_bytes != None:
				label = 'Port %s/tcp (outgoing)'%port
				field = '%sout'%prefix
				print( '%s.label %s'%(field, label) )
				print( '%s.type DERIVE'%field )
				print( '%s.min 0'%field )


if len( sys.argv ) > 1 and sys.argv[1] == 'config':
	title = os.environ.pop( 'title', sys.argv[0].partition('_')[2] )
	print( """graph_title Traffic via %s
graph_vlabel bytes/s
graph_category network
graph_args -l 0"""%(title) )
	if use_v6:
		v6_chains = parse_tables( 'ip6tables' )
		if use_tcp:
			print_traffic_config( ports, 'tcp', 'ipv6', v6_chains )
		if use_udp:
			print_traffic_config( ports, 'udp', 'ipv6', v6_chains )
	if use_v4:
		v4_chains = parse_tables( 'iptables' )
		if use_tcp:
			print_traffic_config( ports, 'tcp', 'ipv4', v4_chains )
		if use_udp:
			print_traffic_config( ports, 'udp', 'ipv4', v4_chains )

	if use_v4 and use_v6 and len( ports ) > 1:
		print( 'total_ipv4.label Total traffic via IPv4' )
		print( 'total_ipv4.type DERIVE' )
		print( 'total_ipv4.min 0' )
		print( 'total_ipv6.label Total traffic via IPv6' )
		print( 'total_ipv6.type DERIVE' )
		print( 'total_ipv6.min 0' )

	print( 'total.label Total traffic' )
	print( 'total.type DERIVE' )
	print( 'total.min 0' )
	sys.exit(0)

if use_v6:
	v6_chains = parse_tables( 'ip6tables' )
	if use_tcp:
		v6_total += print_traffic( ports, 'tcp', 'ipv6', v6_chains )
	if use_udp:
		v6_total += print_traffic( ports, 'udp', 'ipv6', v6_chains )
if use_v4:
	v4_chains = parse_tables( 'iptables' )
	if use_tcp:
		v4_total += print_traffic( ports, 'tcp', 'ipv4', v4_chains )
	if use_udp:
		v4_total += print_traffic( ports, 'udp', 'ipv4', v4_chains )


# 1. wert von jedem wert einzeln.
# falls IPv6 UND IPv6: total fuer IP-version
if use_v4 and use_v6 and len( ports ) > 1:
	print( 'total_ipv4.value %s'%v4_total )
	print( 'total_ipv6.value %s'%v6_total )
total = v4_total + v6_total
print( 'total.value %s'%total )
